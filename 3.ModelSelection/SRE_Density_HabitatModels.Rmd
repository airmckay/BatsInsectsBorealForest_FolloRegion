---
title: "SRE_Density_HabitatModels"
output: html_document
date: "2024-02-02"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Goals 

- Model set 1. Total brown long-eared bat activity compared to total Myotis activity 

- Model set 2: Myotis commuting activity compared to Myotis feeding activity 

Prediction plots 

## Notes and references

"The marginal (no random effects) and conditional (with random effects) can be estimated by predicting the responses for the fixed-only (marginal) and full (conditional) models, correlating to the response data points, and squaring.

Nakagawa, S., and Schielzeth, H. (2013). A general and simple method for obtaining R2 from generalized linear mixed-effects models. Methods in Ecology and Evolution, 4(2), 133â€“142. doi:10.1111/j.2041-210x.2012.00261.x

Nakagawa, S., Johnson, P. C. D., and Schielzeth, H. (2017). The coefficient of determination R2 and intra-class correlation coefficient from generalized linear mixed-effects models revisited and expanded. Journal of The Royal Society Interface, 14(134), 20170213. doi:10.1098/rsif.2017.0213"
https://stats.stackexchange.com/questions/586777/model-fit-r2-for-glmmtmb


```{r}
library(data.table)
library(tidyverse)
library(beepr)
library(lubridate)
library(purrr)
library(janitor)
#renv::install("rstudio/renv")
library(renv)
library(stringr)
library(beepr)
library(kableExtra)
library(papeR)
library(skimr)
library(vtable)
library(ggdark)
library(RColorBrewer)
library(cowplot)
library(readxl)
library(readr)
library(ggstats)
library(ggpmisc)
library(gginnards)
library(ggplot2)
library(colorBlindness)
library(vegan) 
library(TMB)
library(glmmTMB)
library(DHARMa)
library(performance)
library(car)
library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(modelsummary)
library(gt)
library(beepr)

## Setup output directory 
output <- "C:/Users/apmc/OneDrive - Norwegian University of Life Sciences/3. Follo Forest 2021-2023/Manuscripts/Analyses/ForDryad/3.ModelSelection/SRE_Density_HabitatModels/Outputs"

file.name <- "SRE.models"

todays_date <- Sys.Date()
 
dir.name <- str_c(output,"/", file.name, "_", todays_date)
dir.name
 
output_today <- dir.name
output_today

dir.create(output_today)
output_today
# "C:/Users/apmc/OneDrive - Norwegian University of Life Sciences/3. Follo Forest 2021-2023/Manuscripts/Analyses/ForDryad/3.ModelSelection/SRE_Density_HabitatModels/Outputs/SRE.models_2024-02-02"
```

## Import and tidy 
```{r}
bats <- read_csv("C:/Users/apmc/OneDrive - Norwegian University of Life Sciences/3. Follo Forest 2021-2023/Manuscripts/Analyses/ForDryad/2.AggregationCombineCovariates/NightAggregateBats_DensityManuscript/Outputs/NightAggBats_2024-02-01/DensityBats_ForestPhoto.csv", 
 col_types = cols(...1 = col_skip()))

bats <- bats %>% dplyr::mutate(jnight = yday(night), 
                        SitePlotYear = factor(SitePlotYear),
                        Site = factor(Site), 
                        SitePlot = factor(SitePlot), 
                        PlotType = factor(PlotType),
                        year = factor(year), 
                        jnight.f = factor(jnight),
                          manual.id = factor(manual.id), 
                          behavior = factor(behavior), 
                          guild = factor(guild)) %>%
  dplyr::mutate(s.temperature = as.numeric(scale(temperature)),
         s.rainfall = as.numeric(scale(rainfall)),
         s.PC1 = as.numeric(scale(PC1))) 

summary(bats)

summary(bats$s.PC1)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# -2.9250 -0.5261  0.2258  0.0000  0.6270  1.9511 

dim(bats)
# 244470     33
sum(bats$batpass)
# 106519

## Color palette for later 
bats$PlotType <- factor(bats$PlotType, levels=c("Open", "Interior", "Canopy"))
levels(bats$PlotType)
plot.cols <- c("#F57969", "#669F85", "#6D5AA1") 

summary(bats$jnight)
 
### Create a "Season" categorical variable split into three categories evenly:
bats1 <- bats %>% 
  dplyr::mutate(season = factor(case_when(
    jnight %in% 124:170 ~ "Early", 
    jnight %in% 171:217 ~ "Medium", 
    jnight %in% 218:263 ~ "Late"))) %>% 
  dplyr::mutate(season = 
                  factor(season, levels=c("Early", "Medium", "Late"))) 
summary(bats1)

summary(bats1$season) 
# Early Medium   Late 
# 80970  93510  69990
 levels(bats1$season)

 
## Subset for different myotis and brown long-eared (dissolve behavior)
myot <- bats1 %>% filter(manual.id == "MYOT") %>% dplyr::select(-behavior) %>% droplevels() %>% distinct()
dim(myot)
summary(myot)
#16161    33

plau <- bats1 %>% filter(manual.id == "PAUR") %>% dplyr::select(-behavior) %>% droplevels() %>% distinct()
dim(plau)
summary(plau)
#9407   33

bats.map <- bats1 %>% dplyr::select(SitePlotYear, Site, SitePlot, PlotType, s.PC1,
                             year, season, night, jnight, jnight.f, 
                             s.temperature, s.rainfall) %>% distinct()
# 8149 of 12 

## Myotis 
MY <- myot %>% group_by(SitePlotYear, night) %>% dplyr::summarise(batpass = sum(batpass)) 
summary(MY)

mydf <- left_join(MY, bats.map) %>% mutate(taxa = "Myotis species") 
sum(mydf$batpass) # 74633
sum(mydf$batpass == 0) / nrow(mydf)*100 
# 33.40287
summary(mydf)

## Brown long-eared bat 
PL <- plau %>% group_by(SitePlotYear, night) %>% dplyr::summarise(batpass = sum(batpass)) 
summary(PL)


pldf <- left_join(PL, bats.map) %>% mutate(taxa = "Plecotus auritus") 
sum(pldf$batpass) # 2340
sum(pldf$batpass == 0) / nrow(pldf)*100 
# 85.75285
summary(pldf)

#### Myotis behavior data subsets for models 

## Subset for different myotis behaviors  
myot <- bats1 %>% filter(manual.id == "MYOT") %>% droplevels() %>% distinct()
dim(myot)
#24447    34
sum(myot$batpass == 0) / nrow(myot)*100 
# 65.93856 zero observations

myot.c <- bats1 %>% filter(manual.id == "MYOT", behavior == "Commuting") %>% droplevels() %>% distinct()
dim(myot.c)
# 8149   34
sum(myot.c$batpass) # 61006
sum(myot.c$batpass == 0) / nrow(myot.c)*100 
# 34.5 % zero observations 

myot.f <- bats1 %>% filter(manual.id == "MYOT", behavior == "Feeding") %>% droplevels() %>% distinct()
dim(myot.f)
# 8149   38
sum(myot.f$batpass) # 13775
sum(myot.f$batpass == 0) / nrow(myot.f)*100 
# 65.16137 zero observations
# 
dates <- c(124, 150, 160, 171, 194, 206, 218, 236, 263)

dim(pldf)
# 8149   14
dim(mydf)
# 8149   14
```



## Myotis species - Model selection 
```{r}
#' Apply the Poisson GLMM.
# MY1 <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
#               family = "poisson",
#               data = mydf)
# 
# #
# # #' This is the ZIP GLMM.
# MY2 <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
#               family = "poisson",
#               ziformula = ~1,
#               data = mydf)
# 
# #' This is the GP GLMM:
# MY3 <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
#               family = "genpois",
#               ziformula = ~0,
#               data = mydf)
# #
# MY3b <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
#               family = "genpois",
#               ziformula = ~1,         
#               data = mydf)

# #' This is the NB GLMM:
MY4 <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "nbinom2",
              ziformula = ~0,
              data = mydf)


# MY4b <- glmmTMB(batpass ~ PlotType*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
#               family = "nbinom2",
#               ziformula = ~1,
#               data = mydf)
# 
# 
# #' Who is the best so far?
# AIC(MY1, MY2, MY3, MY3b, MY4, MY4b)
# MY1  23 132301.39
# MY2  24 112325.01
# MY3  24  43702.74
# MY3b 25  43668.78 * Best 
# MY4  24  43998.66
# MY4b 16  44536.75
#beep()

# summary(MY1)
# 
# tab_model(MY3b, show.est = TRUE, show.se = TRUE, 
#           show.stat = TRUE, transform = NULL)
# 
# tab_model(MY3b, show.est = TRUE, show.se = TRUE, 
#           show.stat = TRUE, transform = NULL, file = file.path(output_today, "MyotisTotal_M3b_summary.doc"))

```

## Model validation 
```{r}
# #* Model validation using DHARMa for the GP GLM model----
# 
# #' To get more acquainted with the `DHARMa` package, we also show its results 
# #' for the GP GLM. We first obtain the scaled quantile residuals.
# 
E3.gp <- simulateResiduals(fittedModel = MY3b, plot = FALSE)

#' Once we have these we can make a Q-Q plot to check whether the scaled
#' quantile residuals are uniformly distributed.
par(mfrow = c(1,1), mar = c(5,5,2,2))
plotQQunif(E3.gp, testUniformity = TRUE,
           testOutliers = TRUE, testDispersion = TRUE)
#' There are no major problems

#' We also plot the scaled quantile residuals versus the fitted values.
#' This is the `DHARMa` equivalent of the figure with the Pearson residuals
#' vs the fitted values.
par(mfrow = c(1,1), mar = c(5,5,2,2))
plotResiduals(E3.gp, quantreg = TRUE, smoothScatter = FALSE)
#' There are no serious problems.


#' We plot the scaled quantile residuals versus the
#' covariates
par(mfrow = c(2,3), mar = c(5,5,2,2))
plotResiduals(E3.gp, form = mydf$s.rainfall)
plotResiduals(E3.gp, form = mydf$s.temperature)
plotResiduals(E3.gp, form = mydf$season)
plotResiduals(E3.gp, form = mydf$PlotType)
plotResiduals(E3.gp, form = mydf$year)
plotResiduals(E3.gp, form = mydf$s.PC1)

par(mfrow = c(2,1), mar = c(5,5,2,2))
plotResiduals(E3.gp, form = mydf$Site) #Note FF08
plotResiduals(E3.gp, form = mydf$jnight.f)
#' There are no big problems.


#' We can also use `DHARMAa` to check whether the GP GLM can cope with
#' the excessive number of zeros. This graph is the equivalent of the simulation
#' study that we carried out a few minutes ago.
par(mfrow = c(1,1), mar = c(5,5,5,5))
testZeroInflation(MY3b)
# data:  simulationOutput
# ratioObsSim = 0.9456, p-value = 0.608
# alternative hypothesis: two.sided

```

## Plot predictions - Myotis total 
```{r}
#Predict for all nights
summary(mydf)
summary(mydf$s.PC1)
# 0.2258  

# # Create a data frame with all combinations of PlotType, season, and behavior
newdata.m <- data.frame(expand.grid(s.PC1 = seq(from = -2.93,
                                   to = 1.95,
                                   length = 25),
                       PlotType = levels(mydf$PlotType),
                       season = levels(mydf$season),
                       s.temperature = mean(mydf$s.temperature),
                       s.rainfall = mean(mydf$s.rainfall),
                       Site = unique(mydf$Site),
                       year = unique(mydf$year),
                       jnight.f = dates)) 
dim(newdata.m)
# 48600     8
# 
# head(newdata1)
# tail(newdata1)
# 
# # Generate predicted values
# summary(M3b)
# getwd()

predictions.m <- predict(MY3b, type = "response", newdata = newdata.m, se.fit = TRUE)
beep()

# Extract predicted values and standard errors
predicted_values <- predictions.m$fit
standard_errors <- predictions.m$se.fit
# 
# 
# # Add the predicted values to the new data frame
newdata.m$predicted <- predicted_values
newdata.m$se <- standard_errors
newdata.m$upper <-  newdata.m$predicted + (2*newdata.m$se)
newdata.m$lower <- newdata.m$predicted-(2*newdata.m$se)
dim(newdata.m)
# 48600    12

head(newdata.m)
tail(newdata.m) 

## Tally - import data here 
#write.csv(newdata.m, file = file.path(output_today, "PredictionsDataFrame_AllMyotis_M3B_9nights.csv"))


### Now adjust so that you have a dataset where PC1 values are outside the sub-habitat ranges

myOB <- mydf %>% filter(PlotType == "Open") %>% droplevels
summary(myOB$s.PC1)
#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
# -0.6997  0.3574  0.9611  0.7640  1.1265  1.9511 
## Range = -0.6997 - 1.9511

myIB <- mydf %>% filter(PlotType == "Interior") %>% droplevels
summary(myIB$s.PC1)
#     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
# -2.92499 -0.61295 -0.49881 -0.44561  0.05632  0.60446 

myCB <- mydf %>% filter(PlotType == "Canopy") %>% droplevels
summary(myCB$s.PC1)
#     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
# -2.73814 -0.75569  0.09113 -0.31163  0.42900  0.88423 

range(newdata.m$s.PC1)
# -2.93  1.95


# Plot the predicted values 

# Set the colors for each level
plot.cols

seas.labs <- c("Season:Early", "Season:Mid", "Season:Late")
names(seas.labs) <- c("Early", "Medium", "Late")

# Create the ggplot
pred.m <- ggplot(newdata.m, aes(x = s.PC1, y = predicted,
                     group = PlotType, color = PlotType, 
                     fill = PlotType)) +
  # Add average line for each combination of PlotType and Season
  stat_summary(fun = "mean",  
               geom = "line", linewidth = 1) + 
  stat_summary(fun.data = "mean_cl_normal", 
               geom = "ribbon", alpha = 0.75) + 
  # Set the color and fill scale based on PlotType
  scale_color_manual(values = plot.cols) +
  scale_fill_manual(values = plot.cols) +
  # Facet the plot by Season
  facet_wrap(~season, scales = "fixed", ncol = 3,
             labeller = labeller(season = seas.labs)) +
  # Customize the theme for a cleaner look
  theme_minimal() +
  theme(legend.position = "none",
        text = element_text(size = 15),
        plot.title = element_text(face = "bold")) +
  # Change legend title
  labs(x = "", y = "Bat passes per night", 
       title = expression(paste(italic("Myotis "), "total activity"))) +
  scale_color_manual(name = "Habitat", values = plot.cols) +
  scale_fill_manual(name = "Habitat", values = plot.cols) 
pred.m

  
```

### Brown long-eared bats 
```{r}
summary(pldf)
head(pldf)
#' Apply the Poisson GLMM.
PL1 <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "poisson",
              data = pldf)

#
# #' This is the ZIP GLMM.
PL2 <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "poisson",
              ziformula = ~1,
              data = pldf)

#' This is the GP GLMM:
PL3 <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "genpois",
              ziformula = ~0,
              data = pldf)
#
PL3b <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "genpois",
              ziformula = ~1,         
              data = pldf)

# #' This is the NB GLMM:
PL4 <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "nbinom2",
              ziformula = ~0,
              data = pldf)


PL4b <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "nbinom2",
              ziformula = ~1,
              data = pldf)


#' Who is the best so far?
AIC(PL1, PL2, PL3, PL3b, PL4, PL4b)
#      df      AIC
# PL1  23 9387.129
# PL2  24 8688.301
# PL3  24 8411.060
# PL3b 25 8399.784
# PL4  24 8249.345 *Best
# PL4b 25 8251.345
beep()
summary(PL4)

tab_model(PL4, show.est = TRUE, show.se = TRUE, 
          show.stat = TRUE, transform = NULL)

tab_model(PL4, show.est = TRUE, show.se = TRUE, 
          show.stat = TRUE, transform = NULL, file = file.path(output_today, "PlecotusTotal_PL4_summary.doc"))

```

## Model validation 
```{r}
# #* Model validation using DHARMa for the GP GLM model----
# 
# #' To get more acquainted with the `DHARMa` package, we also show its results 
# #' for the GP GLM. We first obtain the scaled quantile residuals.
# 
E3.gp <- simulateResiduals(fittedModel = PL4, plot = FALSE)

#' Once we have these we can make a Q-Q plot to check whether the scaled
#' quantile residuals are uniformly distributed.
par(mfrow = c(1,1), mar = c(5,5,2,2))
plotQQunif(E3.gp, testUniformity = TRUE,
           testOutliers = TRUE, testDispersion = TRUE)
#' There are no major problems

#' We also plot the scaled quantile residuals versus the fitted values.
#' This is the `DHARMa` equivalent of the figure with the Pearson residuals
#' vs the fitted values.
par(mfrow = c(1,1), mar = c(5,5,2,2))
plotResiduals(E3.gp, quantreg = TRUE, smoothScatter = FALSE)
#' There are no serious problems.


#' We plot the scaled quantile residuals versus the
#' covariates
par(mfrow = c(2,3), mar = c(5,5,2,2))
plotResiduals(E3.gp, form = pldf$s.rainfall)
plotResiduals(E3.gp, form = pldf$s.temperature)
plotResiduals(E3.gp, form = pldf$season)
plotResiduals(E3.gp, form = pldf$PlotType)
plotResiduals(E3.gp, form = pldf$year)
plotResiduals(E3.gp, form = pldf$s.PC1)

par(mfrow = c(2,1), mar = c(5,5,2,2))
plotResiduals(E3.gp, form = pldf$Site) #Note FF08
plotResiduals(E3.gp, form = pldf$jnight.f)
#' There are no big problems.

#' We can also use `DHARMAa` to check whether the GP GLM can cope with
#' the excessive number of zeros. This graph is the equivalent of the simulation
#' study that we carried out a few minutes ago.
par(mfrow = c(1,1), mar = c(5,5,5,5))
testZeroInflation(PL4)

```

## Plot predictions - Plecotus 
```{r}
#Predict for 9 nights 

# # Create a data frame with all combinations of PlotType, season, and behavior
newdata.p <- data.frame(expand.grid(s.PC1 = seq(from = -2.93,
                                   to = 1.95,
                                   length = 25),
                       PlotType = levels(pldf$PlotType),
                       season = levels(pldf$season),
                       s.temperature = mean(pldf$s.temperature),
                       s.rainfall = mean(pldf$s.rainfall),
                       Site = unique(pldf$Site),
                       year = unique(pldf$year),
                       jnight.f = dates)) 
dim(newdata.p)
# 48600     8
# 

predictions.p <- predict(PL4, type = "response", newdata = newdata.p, se.fit = TRUE)
beep()

# Extract predicted values and standard errors
predicted_values <- predictions.p$fit
standard_errors <- predictions.p$se.fit
# 
# 
# # Add the predicted values to the new data frame
newdata.p$predicted <- predicted_values
newdata.p$se <- standard_errors
newdata.p$upper <-  newdata.p$predicted + (2*newdata.p$se)
newdata.p$lower <- newdata.p$predicted-(2*newdata.p$se)
dim(newdata.p)
# 48600    12

head(newdata.p)
tail(newdata.p) 


# write.csv(newdata.p, file = file.path(output_today, "PredictionsDataFrame_AllPlecotus_PL4_9nights.csv"))

# Plot the predicted values 

# Set the colors for each level
plot.cols

seas.labs <- c("Season:Early", "Season:Mid", "Season:Late")
names(seas.labs) <- c("Early", "Medium", "Late")

# Create the ggplot
pred.p <- ggplot(newdata.p, aes(x = s.PC1, y = predicted,
                     group = PlotType, color = PlotType, 
                     fill = PlotType)) +
  
  # Add average line for each combination of PlotType and Season
  stat_summary(fun = "mean",  
               geom = "line", linewidth = 1) + 
  stat_summary(fun.data = "mean_cl_normal", 
               geom = "ribbon", alpha = 0.75) + 
  # Set the color and fill scale based on PlotType
  scale_color_manual(values = plot.cols) +
  scale_fill_manual(values = plot.cols) +
  
  # Facet the plot by Season
  facet_wrap(~season, scales = "fixed", ncol = 3,
             labeller = labeller(season = seas.labs)) +
  
  # Customize the theme for a cleaner look
  theme_minimal() +
  theme(legend.position = "none",
        text = element_text(size = 15),
        plot.title = element_text(face = "bold")) +
 
  # Change legend title
  labs(x = "", y = "", 
       title = expression(paste(italic("P. auritus "), "total activity"))) +
  scale_color_manual(name = "Habitat", values = plot.cols) +
  scale_fill_manual(name = "Habitat", values = plot.cols) 
pred.p

# windows()
cowplot::plot_grid(pred.p, pred.m, nrow = 2) 

summary(newdata.m)
summary(newdata.p)

```


## Myotis commuting - Model selection 
```{r}

summary(myot.c)

#' Apply the Poisson GLMM.
M1c <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "poisson",
              data = myot.c)

#
# #' This is the ZIP GLMM.
M2c <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "poisson",
              ziformula = ~1,
              data = myot.c)

#' This is the GP GLMM:
M3c <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "genpois",
              ziformula = ~0,
              data = myot.c)

 
M3cb <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "genpois",
              ziformula = ~1,         
              data = myot.c)


# #' This is the NB GLMM:
M4c <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "nbinom2",
              ziformula = ~0,
              data = myot.c)


M4cb <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "nbinom2",
              ziformula = ~1,
              data = myot.c)


#' Who is the best so far?
AIC(M1c, M2c, M3c, M3cb, M4c, M4cb)

#    df  p)     AIC
# M1c  23 107272.51
# M2c  24  91188.46
# M3c  24  41677.00
# M3cb 25  41645.00 *Best
# M4c  24  41895.11
# M4cb 25  41897.11
beep()


tab_model(M3cb, show.est = TRUE, show.se = TRUE, 
          show.stat = TRUE, transform = NULL, file = file.path(output_today, "MyotisCommuting_M3b_summary.doc"))


```

## Model validation 
```{r}
# #* Model validation using DHARMa for the GP GLM model----
# 
# #' To get more acquainted with the `DHARMa` package, we also show its results 
# #' for the GP GLM. We first obtain the scaled quantile residuals.
# 
E3.gp <- simulateResiduals(fittedModel = M3cb, plot = FALSE)

#' Once we have these we can make a Q-Q plot to check whether the scaled
#' quantile residuals are uniformly distributed.
par(mfrow = c(1,1), mar = c(5,5,2,2))
plotQQunif(E3.gp, testUniformity = TRUE,
           testOutliers = TRUE, testDispersion = TRUE)
#' There are no major problems

#' We also plot the scaled quantile residuals versus the fitted values.
#' This is the `DHARMa` equivalent of the figure with the Pearson residuals
#' vs the fitted values.
par(mfrow = c(1,1), mar = c(5,5,2,2))
plotResiduals(E3.gp, quantreg = TRUE, smoothScatter = FALSE)
#' There are no serious problems.


#' We plot the scaled quantile residuals versus the
#' covariates
par(mfrow = c(2,3), mar = c(5,5,2,2))
plotResiduals(E3.gp, form = myot.c$s.rainfall)
plotResiduals(E3.gp, form = myot.c$s.temperature)
plotResiduals(E3.gp, form = myot.c$season)
plotResiduals(E3.gp, form = myot.c$PlotType)
plotResiduals(E3.gp, form = myot.c$year)
plotResiduals(E3.gp, form = myot.c$s.PC1)

par(mfrow = c(2,1), mar = c(5,5,2,2))
plotResiduals(E3.gp, form = myot.c$Site) #Note FF08
plotResiduals(E3.gp, form = myot.c$jnight.f)
#' There are no big problems.


#' We can also use `DHARMAa` to check whether the GP GLM can cope with
#' the excessive number of zeros. This graph is the equivalent of the simulation
#' study that we carried out a few minutes ago.
par(mfrow = c(1,1), mar = c(5,5,5,5))
testZeroInflation(M3cb)
# data:  simulationOutput


```





## Plot predictions 
```{r}
#Predict for all nights


# # Create a data frame with all combinations of PlotType, season, and behavior
newdatac <- data.frame(expand.grid(s.PC1 = seq(from = -2.90,
                                   to = 1.93,
                                   length = 25),
                       PlotType = levels(myot.c$PlotType),
                       season = levels(myot.c$season),
                       s.temperature = mean(myot.c$s.temperature),
                       s.rainfall = mean(myot.c$s.rainfall),
                       Site = unique(myot.c$Site),
                       year = unique(myot.c$year),
                       jnight.f = dates)) 
dim(newdatac)
# 48600     8
# 
# head(newdata1)
# tail(newdata1)
# 
# # Generate predicted values
# summary(M3b)
# getwd()

predictions.c <- predict(M3cb, type = "response", newdata = newdatac, se.fit = TRUE)


# Extract predicted values and standard errors
predicted_values <- predictions.c$fit
standard_errors <- predictions.c$se.fit
# 
# 
# # Add the predicted values to the new data frame
newdatac$predicted <- predicted_values
newdatac$se <- standard_errors
newdatac$upper <-  newdatac$predicted + (2*newdatac$se)
newdatac$lower <- newdatac$predicted-(2*newdatac$se)
dim(newdatac)
# 48600    12

## Tally - import data here 
#write.csv(newdatac, file = file.path(output_today, "PredictionsDataFrame_MyotisCommuting_M3cb_9nights.csv"))

#newdata1 <- #IMPORT HERE
head(newdatac)
tail(newdatac) 

# Plot the predicted values 

# Set the colors for each level
plot.cols

seas.labs <- c("Season:Early", "Season:Mid", "Season:Late")
names(seas.labs) <- c("Early", "Medium", "Late")

# Create the ggplot
pred.c <- ggplot(newdatac, aes(x = s.PC1, y = predicted,
                     group = PlotType, color = PlotType, 
                     fill = PlotType)) +
  
  # Add average line for each combination of PlotType and Season
  stat_summary(fun = "mean",  
               geom = "line", linewidth = 1) + 
  stat_summary(fun.data = "mean_cl_normal", 
               geom = "ribbon", alpha = 0.75) + 
  # Set the color and fill scale based on PlotType
  scale_color_manual(values = plot.cols) +
  scale_fill_manual(values = plot.cols) +
  
  # Facet the plot by Season
  facet_wrap(~season, scales = "fixed", ncol = 3,
             labeller = labeller(season = seas.labs)) +
  
  # Customize the theme for a cleaner look
  theme_minimal() +
  theme(legend.position = "none",
        text = element_text(size = 15),
        plot.title = element_text(face = "bold")) +
 
  # Change legend title
  labs(x = "Habitat openness", y = "Bat passes per night", 
       title = 
         expression(paste(italic("Myotis "), "commuting activity"))) +
  scale_color_manual(name = "Habitat", values = plot.cols) +
  scale_fill_manual(name = "Habitat", values = plot.cols) 
pred.c

# pred.f
# pred.c


```

## Myotis feeding - Model selection 
```{r}
#' Apply the Poisson GLMM.
M1f <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "poisson",
              data = myot.f)


#' This is the ZIP GLMM.
M2f <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "poisson",
              ziformula = ~1,
              data = myot.f)


#' This is the GP GLMM:
M3f <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "genpois",
              ziformula = ~0,
              data = myot.f)
#


M3fb <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "genpois",
              ziformula = ~1,         
              data = myot.f)


# #' This is the NB GLMM:
M4f <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "nbinom2",
              ziformula = ~0,
              data = myot.f)
# 
M4fb <- glmmTMB(batpass ~ PlotType*s.PC1*season + s.temperature + s.rainfall + year + (1|Site) + (1|jnight.f) ,
              family = "nbinom2",
              ziformula = ~1,
              data = myot.f)


#' Who is the best so far?
AIC(M1f, M2f, M3f, M3fb, M4f, M4fb)
beep()
#      df      AIC
# M1f  23 41918.20
# M2f  24 33362.75
# M3f  24 21190.08 * Best
# M3fb 25 21192.08
# M4f  24 21409.27
# M4fb 25 21411.27

tab_model(M3f, show.est = TRUE, show.se = TRUE, 
          show.stat = TRUE, transform = NULL)

summary(M3f)

tab_model(M3f, show.est = TRUE, show.se = TRUE, 
          show.stat = TRUE, transform = NULL, file = file.path(output_today, "MyotisFeeding_M3f_summary.doc"))

```


## Model validation 
```{r}
# #* Model validation using DHARMa for the GP GLM model----
# 
#' To get more acquainted with the `DHARMa` package, we also show its results
#' for the GP GLM. We first obtain the scaled quantile residuals.

E3.gp <- simulateResiduals(fittedModel = M3f, plot = FALSE)

#' Once we have these we can make a Q-Q plot to check whether the scaled
#' quantile residuals are uniformly distributed.
par(mfrow = c(1,1), mar = c(5,5,2,2))
plotQQunif(E3.gp, testUniformity = TRUE,
           testOutliers = TRUE, testDispersion = TRUE)
#' There are no major problems

#' We also plot the scaled quantile residuals versus the fitted values.
#' This is the `DHARMa` equivalent of the figure with the Pearson residuals
#' vs the fitted values.
par(mfrow = c(1,1), mar = c(5,5,2,2))
plotResiduals(E3.gp, quantreg = TRUE, smoothScatter = FALSE)
#' There are no serious problems.


#' We plot the scaled quantile residuals versus the
#' covariates
par(mfrow = c(2,3), mar = c(5,5,2,2))
plotResiduals(E3.gp, form = myot.f$s.rainfall)
plotResiduals(E3.gp, form = myot.f$s.temperature)
plotResiduals(E3.gp, form = myot.f$season)
plotResiduals(E3.gp, form = myot.f$PlotType)
plotResiduals(E3.gp, form = myot.f$year)
plotResiduals(E3.gp, form = myot.f$s.PC1)

par(mfrow = c(2,1), mar = c(5,5,2,2))
plotResiduals(E3.gp, form = myot.f$Site) #Note FF08
plotResiduals(E3.gp, form = myot.f$jnight.f)
#' There are no big problems.


#' We can also use `DHARMAa` to check whether the GP GLM can cope with
#' the excessive number of zeros. This graph is the equivalent of the simulation
#' study that we carried out a few minutes ago.
par(mfrow = c(1,1), mar = c(5,5,5,5))
testZeroInflation(M3f)
# data:  simulationOutput
# ratioObsSim = 0.94548, p-value = 0.632
# alternative hypothesis: two.side

summary(M3f)

```

## Plot predictions 
```{r}
#Predict for all jnights 
summary(myot.f$jnight)

# 
# Create a data frame with all combinations of PlotType, season, and behavior
newdataf <- data.frame(expand.grid(s.PC1 = seq(from = -2.90,
                                   to = 1.93,
                                   length = 25),
                       PlotType = levels(myot.f$PlotType),
                       season = levels(myot.f$season),
                       s.temperature = mean(myot.f$s.temperature),
                       s.rainfall = mean(myot.f$s.rainfall),
                       Site = unique(myot.f$Site),
                       year = unique(myot.f$year),
                       jnight.f = dates))  
# 
head(newdataf)
tail(newdataf)
# 
# # Generate predicted values
# summary(M3f)
# getwd()

predictions.f <- predict(M3f, type = "response", newdata = newdataf, se.fit = TRUE)
beep()

# Extract predicted values and standard errors
predicted_values <- predictions.f$fit
standard_errors <- predictions.f$se.fit


# Add the predicted values to the new data frame
newdataf$predicted <- predicted_values
newdataf$se <- standard_errors
newdataf$upper <-  newdataf$predicted + (2*newdataf$se)
newdataf$lower <- newdataf$predicted-(2*newdataf$se)
dim(newdataf)
# 48600    12

## Tally - import data here 
# write.csv(newdataf, file = file.path(output_today, "PredictionsDataFrame_MyotisFeeding_M3f_9nights.csv"))

#newdata1 <- #IMPORT HERE

head(newdataf)
tail(newdataf) 
# Plot the predicted values 


# Set the colors for each level
plot.cols
# "#F57969" "#669F85" "#6D5AA1"
# Create the ggplot
seas.labs <- c("Season:Early", "Season:Mid", "Season:Late")
names(seas.labs) <- c("Early", "Medium", "Late")

pred.f <- ggplot(newdataf, aes(x = s.PC1, y = predicted,
                     group = PlotType, color = PlotType, fill = PlotType)) +
  
  # Add average line for each combination of PlotType and Season
  stat_summary(fun = "mean",  
               geom = "line", linewidth = 1) + 
  stat_summary(fun.data = "mean_cl_normal", 
               geom = "ribbon", alpha = 0.75) + 
  # Set the color and fill scale based on PlotType
  scale_color_manual(values = plot.cols) +
  scale_fill_manual(values = plot.cols) +
  
  # Facet the plot by Season
  facet_wrap(~season, scales = "fixed", ncol = 3, 
             labeller = labeller(season = seas.labs))  +
  
  # Customize the theme for a cleaner look
  theme_minimal() +
  theme(legend.position = "none",
        text = element_text(size = 15),
        plot.title = element_text(face = "bold")) +
 
  # Change legend title
  labs(x = "Habitat openness", y = "", 
       title = 
         expression(paste(italic("Myotis "), "feeding activity"))) +
  scale_color_manual(name = "Habitat", values = plot.cols) +
  scale_fill_manual(name = "Habitat", values = plot.cols)
pred.f

## Now just export this to get the legend 
# ggsave(path = output_today, filename = "legendplot.tiff", width = 10, height = 8, device='tiff', dpi=300) 

windows()
SREpred <- cowplot::plot_grid(pred.m, pred.p, pred.c, pred.f, nrow = 2, ncol = 2, labels = c("a.", "b.", "c.", "d."))  
SREpred

ggsave(path = output_today, filename = "SREmodelPreds.tiff", width = 12, height = 8, device='tiff', dpi=600) 

```


### Plot predictions for all 4 models and visualize where values are outside of the range for each plot
```{r}
## Import the 4 model prediction sets 

newdatam <- read_csv("C:/Users/apmc/OneDrive - Norwegian University of Life Sciences/3. Follo Forest 2021-2023/Manuscripts/Analyses/ForDryad/3.ModelSelection/SRE_Density_HabitatModels/Inputs/PredictionsDataFrame_AllMyotis_M3B_9nights.csv", 
 col_types = cols(...1 = col_skip()))
# 48600 obs of 12 vars 

newdatap <-  read_csv("C:/Users/apmc/OneDrive - Norwegian University of Life Sciences/3. Follo Forest 2021-2023/Manuscripts/Analyses/ForDryad/3.ModelSelection/SRE_Density_HabitatModels/Inputs/PredictionsDataFrame_AllPlecotus_PL4_9nights.csv", 
 col_types = cols(...1 = col_skip()))
# 48600 obs of 12 vars 

newdatac <- read_csv("C:/Users/apmc/OneDrive - Norwegian University of Life Sciences/3. Follo Forest 2021-2023/Manuscripts/Analyses/ForDryad/3.ModelSelection/SRE_Density_HabitatModels/Inputs/PredictionsDataFrame_MyotisCommuting_M3cb_9nights.csv", 
 col_types = cols(...1 = col_skip()))
# 48600 obs of 12 vars 

newdataf <- read_csv("C:/Users/apmc/OneDrive - Norwegian University of Life Sciences/3. Follo Forest 2021-2023/Manuscripts/Analyses/ForDryad/3.ModelSelection/SRE_Density_HabitatModels/Inputs/PredictionsDataFrame_MyotisFeeding_M3f_9nights.csv", 
 col_types = cols(...1 = col_skip()))
# 48600 obs of 12 vars 

## For plotting facet labels 
seas.labs <- c("Season:Early", "Season:Mid", "Season:Late")
names(seas.labs) <- c("Early", "Medium", "Late")


################################################################################
################################################################################
### Myotis total activity predictions
# Subset to columns we are actually interested in for ease
newdatam_sub <-subset(newdatam, select = c("s.PC1", "season", "PlotType","predicted"))
myot_sub   <-subset(mydf, select = c("s.PC1", "season", "PlotType"))

#### Find the ranges we want to predict within for each grouping ####
# Canopy
myot_sub_can_early <-myot_sub[myot_sub$season== "Early" & myot_sub$PlotType== "Canopy",  ]
can_early_max <-max(myot_sub_can_early$s.PC1)
can_early_min <-min(myot_sub_can_early$s.PC1)

myot_sub_can_late <-myot_sub[myot_sub$season== "Late" & myot_sub$PlotType== "Canopy",  ]
can_late_max <-max(myot_sub_can_late$s.PC1)
can_late_min <-min(myot_sub_can_late$s.PC1)

myot_sub_can_mid <-myot_sub[myot_sub$season== "Medium" & myot_sub$PlotType== "Canopy",  ]
can_mid_max <-max(myot_sub_can_mid$s.PC1)
can_mid_min <-min(myot_sub_can_mid$s.PC1)

# Interior
myot_sub_int_early <-myot_sub[myot_sub$season== "Early" & myot_sub$PlotType== "Interior",  ]
int_early_max <-max(myot_sub_int_early$s.PC1)
int_early_min <-min(myot_sub_int_early$s.PC1)

myot_sub_int_late <-myot_sub[myot_sub$season== "Late" & myot_sub$PlotType== "Interior",  ]
int_late_max <-max(myot_sub_int_late$s.PC1)
int_late_min <-min(myot_sub_int_late$s.PC1)

myot_sub_int_mid <-myot_sub[myot_sub$season== "Medium" & myot_sub$PlotType== "Interior",  ]
int_mid_max <-max(myot_sub_int_mid$s.PC1)
int_mid_min <-min(myot_sub_int_mid$s.PC1)

# Open
myot_sub_open_early <-myot_sub[myot_sub$season== "Early" & myot_sub$PlotType== "Open",  ]
open_early_max <-max(myot_sub_open_early$s.PC1)
open_early_min <-min(myot_sub_open_early$s.PC1)

myot_sub_open_late <-myot_sub[myot_sub$season== "Late" & myot_sub$PlotType== "Open",  ]
open_late_max <-max(myot_sub_open_late$s.PC1)
open_late_min <-min(myot_sub_open_late$s.PC1)

myot_sub_open_mid <-myot_sub[myot_sub$season== "Medium" & myot_sub$PlotType== "Open",  ]
open_mid_max <-max(myot_sub_open_mid$s.PC1)
open_mid_min <-min(myot_sub_open_mid$s.PC1)


#### Crop the predictions to these ranges ####
# canopy
newdatam_can_early <-newdatam_sub[newdatam_sub$season== "Early" & newdatam_sub$PlotType== "Canopy" &
                                  newdatam_sub$s.PC1 >= can_early_min & newdatam_sub$s.PC1 <= can_early_max ,  ]

newdatam_can_late <-newdatam_sub[newdatam_sub$season== "Late" & newdatam_sub$PlotType== "Canopy" &
                                    newdatam_sub$s.PC1 >= can_late_min & newdatam_sub$s.PC1 <= can_late_max ,  ]

newdatam_can_mid <-newdatam_sub[newdatam_sub$season== "Medium" & newdatam_sub$PlotType== "Canopy" &
                                   newdatam_sub$s.PC1 >= can_mid_min & newdatam_sub$s.PC1 <= can_mid_max ,  ]

# interior
newdatam_int_early <-newdatam_sub[newdatam_sub$season== "Early" & newdatam_sub$PlotType== "Interior" &
                                    newdatam_sub$s.PC1 >= int_early_min & newdatam_sub$s.PC1 <= int_early_max ,  ]

newdatam_int_late <-newdatam_sub[newdatam_sub$season== "Late" & newdatam_sub$PlotType== "Interior" &
                                   newdatam_sub$s.PC1 >= int_late_min & newdatam_sub$s.PC1 <= int_late_max ,  ]

newdatam_int_mid <-newdatam_sub[newdatam_sub$season== "Medium" & newdatam_sub$PlotType== "Interior" &
                                  newdatam_sub$s.PC1 >= int_mid_min & newdatam_sub$s.PC1 <= int_mid_max ,  ]

# open
newdatam_open_early <-newdatam_sub[newdatam_sub$season== "Early" & newdatam_sub$PlotType== "Open" &
                                    newdatam_sub$s.PC1 >= open_early_min & newdatam_sub$s.PC1 <= open_early_max ,  ]

newdatam_open_late <-newdatam_sub[newdatam_sub$season== "Late" & newdatam_sub$PlotType== "Open" &
                                   newdatam_sub$s.PC1 >= open_late_min & newdatam_sub$s.PC1 <= open_late_max ,  ]

newdatam_open_mid <-newdatam_sub[newdatam_sub$season== "Medium" & newdatam_sub$PlotType== "Open" &
                                  newdatam_sub$s.PC1 >= open_mid_min & newdatam_sub$s.PC1 <= open_mid_max ,  ]

#### recombine prediction dataframes ####
test <-rbind(newdatam_can_early, newdatam_can_late, newdatam_can_mid,
             newdatam_int_early, newdatam_int_late, newdatam_int_mid,
             newdatam_open_early,newdatam_open_late, newdatam_open_mid )

# Reorder factor levels for plotting
test$season   <- factor(test$season, levels = c("Early", "Medium", "Late"))
test$PlotType <- factor(test$PlotType, levels = c("Open", "Interior", "Canopy"))

newdatam_sub$season   <- factor(newdatam_sub$season, levels = c("Early", "Medium", "Late"))
newdatam_sub$PlotType <- factor(newdatam_sub$PlotType, levels = c("Open", "Interior", "Canopy"))


#### plot ####
# initial plot is for the original predictions
(p<-ggplot(newdatam_sub, aes(x = s.PC1, y = predicted,
                             group = PlotType, color = PlotType, fill = PlotType)) +
   
   # Add average line for each combination of PlotType and Season
   stat_summary(fun = "mean",  
                geom = "line", linewidth = 1, linetype =2) + 
   stat_summary(fun.data = "mean_cl_normal", 
                geom = "ribbon", alpha = 0.1) + 
   # Set the color and fill scale based on PlotType
   scale_color_manual(values = plot.cols) +
   scale_fill_manual(values = plot.cols) +
   
   # Facet the plot by Season
   facet_wrap(~season, scales = "fixed", ncol = 3, 
              labeller = labeller(season = seas.labs))  +
   
   # Customize the theme for a cleaner look
   theme_minimal() +
   theme(legend.position = "none",
         text = element_text(size = 15),
         plot.title = element_text(face = "bold")) +
   
   # Change legend title
   labs(x = "", y = "Bat passes per night", 
        title =  expression(paste(italic("Myotis "), "total activity"))) +
   scale_color_manual(name = "Habitat", values = plot.cols) +
   scale_fill_manual(name = "Habitat", values = plot.cols) +
   xlim(-3, 2)
)

# Now readd the predictions within range as an overlay
(predm<-p + 
    stat_summary(data = test, fun = "mean",  
                 geom = "line", linewidth = 1, linetype = 1, alpha=0.9) + 
    stat_summary(data = test, fun.data = "mean_cl_normal", 
                 geom = "ribbon", alpha = 0.75) )

################################################################################
################################################################################
################################################################################
################################################################################

### Myotis total activity predictions
# Subset to columns we are actually interested in for ease
newdatap_sub <-subset(newdatap, select = c("s.PC1", "season", "PlotType","predicted"))
plau_sub   <-subset(pldf, select = c("s.PC1", "season", "PlotType"))

#### Find the ranges we want to predict within for each grouping ####
# Canopy
plau_sub_can_early <-plau_sub[plau_sub$season== "Early" & plau_sub$PlotType== "Canopy",  ]
can_early_max <-max(plau_sub_can_early$s.PC1)
can_early_min <-min(plau_sub_can_early$s.PC1)

plau_sub_can_late <-plau_sub[plau_sub$season== "Late" & plau_sub$PlotType== "Canopy",  ]
can_late_max <-max(plau_sub_can_late$s.PC1)
can_late_min <-min(plau_sub_can_late$s.PC1)

plau_sub_can_mid <-plau_sub[plau_sub$season== "Medium" & plau_sub$PlotType== "Canopy",  ]
can_mid_max <-max(plau_sub_can_mid$s.PC1)
can_mid_min <-min(plau_sub_can_mid$s.PC1)

# Interior
plau_sub_int_early <-plau_sub[plau_sub$season== "Early" & plau_sub$PlotType== "Interior",  ]
int_early_max <-max(plau_sub_int_early$s.PC1)
int_early_min <-min(plau_sub_int_early$s.PC1)

plau_sub_int_late <-plau_sub[plau_sub$season== "Late" & plau_sub$PlotType== "Interior",  ]
int_late_max <-max(plau_sub_int_late$s.PC1)
int_late_min <-min(plau_sub_int_late$s.PC1)

plau_sub_int_mid <-plau_sub[plau_sub$season== "Medium" & plau_sub$PlotType== "Interior",  ]
int_mid_max <-max(plau_sub_int_mid$s.PC1)
int_mid_min <-min(plau_sub_int_mid$s.PC1)

# Open
plau_sub_open_early <-plau_sub[plau_sub$season== "Early" & plau_sub$PlotType== "Open",  ]
open_early_max <-max(plau_sub_open_early$s.PC1)
open_early_min <-min(plau_sub_open_early$s.PC1)

plau_sub_open_late <-plau_sub[plau_sub$season== "Late" & plau_sub$PlotType== "Open",  ]
open_late_max <-max(plau_sub_open_late$s.PC1)
open_late_min <-min(plau_sub_open_late$s.PC1)

plau_sub_open_mid <-plau_sub[plau_sub$season== "Medium" & plau_sub$PlotType== "Open",  ]
open_mid_max <-max(plau_sub_open_mid$s.PC1)
open_mid_min <-min(plau_sub_open_mid$s.PC1)


#### Crop the predictions to these ranges ####
# canopy
newdatap_can_early <-newdatap_sub[newdatap_sub$season== "Early" & newdatap_sub$PlotType== "Canopy" &
                                  newdatap_sub$s.PC1 >= can_early_min & newdatap_sub$s.PC1 <= can_early_max ,  ]

newdatap_can_late <-newdatap_sub[newdatap_sub$season== "Late" & newdatap_sub$PlotType== "Canopy" &
                                    newdatap_sub$s.PC1 >= can_late_min & newdatap_sub$s.PC1 <= can_late_max ,  ]

newdatap_can_mid <-newdatap_sub[newdatap_sub$season== "Medium" & newdatap_sub$PlotType== "Canopy" &
                                   newdatap_sub$s.PC1 >= can_mid_min & newdatap_sub$s.PC1 <= can_mid_max ,  ]

# interior
newdatap_int_early <-newdatap_sub[newdatap_sub$season== "Early" & newdatap_sub$PlotType== "Interior" &
                                    newdatap_sub$s.PC1 >= int_early_min & newdatap_sub$s.PC1 <= int_early_max ,  ]

newdatap_int_late <-newdatap_sub[newdatap_sub$season== "Late" & newdatap_sub$PlotType== "Interior" &
                                   newdatap_sub$s.PC1 >= int_late_min & newdatap_sub$s.PC1 <= int_late_max ,  ]

newdatap_int_mid <-newdatap_sub[newdatap_sub$season== "Medium" & newdatap_sub$PlotType== "Interior" &
                                  newdatap_sub$s.PC1 >= int_mid_min & newdatap_sub$s.PC1 <= int_mid_max ,  ]

# open
newdatap_open_early <-newdatap_sub[newdatap_sub$season== "Early" & newdatap_sub$PlotType== "Open" &
                                    newdatap_sub$s.PC1 >= open_early_min & newdatap_sub$s.PC1 <= open_early_max ,  ]

newdatap_open_late <-newdatap_sub[newdatap_sub$season== "Late" & newdatap_sub$PlotType== "Open" &
                                   newdatap_sub$s.PC1 >= open_late_min & newdatap_sub$s.PC1 <= open_late_max ,  ]

newdatap_open_mid <-newdatap_sub[newdatap_sub$season== "Medium" & newdatap_sub$PlotType== "Open" &
                                  newdatap_sub$s.PC1 >= open_mid_min & newdatap_sub$s.PC1 <= open_mid_max ,  ]

#### recombine prediction dataframes ####
test <-rbind(newdatap_can_early, newdatap_can_late, newdatap_can_mid,
             newdatap_int_early, newdatap_int_late, newdatap_int_mid,
             newdatap_open_early,newdatap_open_late, newdatap_open_mid )

# Reorder factor levels for plotting
test$season   <- factor(test$season, levels = c("Early", "Medium", "Late"))
test$PlotType <- factor(test$PlotType, levels = c("Open", "Interior", "Canopy"))

newdatap_sub$season   <- factor(newdatap_sub$season, levels = c("Early", "Medium", "Late"))
newdatap_sub$PlotType <- factor(newdatap_sub$PlotType, levels = c("Open", "Interior", "Canopy"))


#### plot ####
# initial plot is for the original predictions
(p<-ggplot(newdatap_sub, aes(x = s.PC1, y = predicted,
                             group = PlotType, color = PlotType, fill = PlotType)) +
   
   # Add average line for each combination of PlotType and Season
   stat_summary(fun = "mean",  
                geom = "line", linewidth = 1, linetype =2) + 
   stat_summary(fun.data = "mean_cl_normal", 
                geom = "ribbon", alpha = 0.1) + 
   # Set the color and fill scale based on PlotType
   scale_color_manual(values = plot.cols) +
   scale_fill_manual(values = plot.cols) +
   
   # Facet the plot by Season
   facet_wrap(~season, scales = "fixed", ncol = 3, 
              labeller = labeller(season = seas.labs))  +
   
   # Customize the theme for a cleaner look
   theme_minimal() +
   theme(legend.position = "none",
         text = element_text(size = 15),
         plot.title = element_text(face = "bold")) +
   
   # Change legend title
   labs(x = "", y = "", 
        title =  expression(paste(italic("P. auritus "), "total activity"))) +
   scale_color_manual(name = "Habitat", values = plot.cols) +
   scale_fill_manual(name = "Habitat", values = plot.cols) +
   xlim(-3, 2)
)

# Now readd the predictions within range as an overlay
(predp<-p + 
    stat_summary(data = test, fun = "mean",  
                 geom = "line", linewidth = 1, linetype = 1, alpha=0.9) + 
    stat_summary(data = test, fun.data = "mean_cl_normal", 
                 geom = "ribbon", alpha = 0.75) )



################################################################################


### Myotis feeding activity predictions
# Subset to columns we are actually interested in for ease
newdataf_sub <-subset(newdataf, select = c("s.PC1", "season", "PlotType","predicted"))
myot.f_sub   <-subset(myot.f, select = c("s.PC1", "season", "PlotType"))

#### Find the ranges we want to predict within for each grouping ####
# Canopy
myot.f_sub_can_early <-myot.f_sub[myot.f_sub$season== "Early" & myot.f_sub$PlotType== "Canopy",  ]
can_early_max <-max(myot.f_sub_can_early$s.PC1)
can_early_min <-min(myot.f_sub_can_early$s.PC1)

myot.f_sub_can_late <-myot.f_sub[myot.f_sub$season== "Late" & myot.f_sub$PlotType== "Canopy",  ]
can_late_max <-max(myot.f_sub_can_late$s.PC1)
can_late_min <-min(myot.f_sub_can_late$s.PC1)

myot.f_sub_can_mid <-myot.f_sub[myot.f_sub$season== "Medium" & myot.f_sub$PlotType== "Canopy",  ]
can_mid_max <-max(myot.f_sub_can_mid$s.PC1)
can_mid_min <-min(myot.f_sub_can_mid$s.PC1)

# Interior
myot.f_sub_int_early <-myot.f_sub[myot.f_sub$season== "Early" & myot.f_sub$PlotType== "Interior",  ]
int_early_max <-max(myot.f_sub_int_early$s.PC1)
int_early_min <-min(myot.f_sub_int_early$s.PC1)

myot.f_sub_int_late <-myot.f_sub[myot.f_sub$season== "Late" & myot.f_sub$PlotType== "Interior",  ]
int_late_max <-max(myot.f_sub_int_late$s.PC1)
int_late_min <-min(myot.f_sub_int_late$s.PC1)

myot.f_sub_int_mid <-myot.f_sub[myot.f_sub$season== "Medium" & myot.f_sub$PlotType== "Interior",  ]
int_mid_max <-max(myot.f_sub_int_mid$s.PC1)
int_mid_min <-min(myot.f_sub_int_mid$s.PC1)

# Open
myot.f_sub_open_early <-myot.f_sub[myot.f_sub$season== "Early" & myot.f_sub$PlotType== "Open",  ]
open_early_max <-max(myot.f_sub_open_early$s.PC1)
open_early_min <-min(myot.f_sub_open_early$s.PC1)

myot.f_sub_open_late <-myot.f_sub[myot.f_sub$season== "Late" & myot.f_sub$PlotType== "Open",  ]
open_late_max <-max(myot.f_sub_open_late$s.PC1)
open_late_min <-min(myot.f_sub_open_late$s.PC1)

myot.f_sub_open_mid <-myot.f_sub[myot.f_sub$season== "Medium" & myot.f_sub$PlotType== "Open",  ]
open_mid_max <-max(myot.f_sub_open_mid$s.PC1)
open_mid_min <-min(myot.f_sub_open_mid$s.PC1)


#### Crop the predictions to these ranges ####
# canopy
newdataf_can_early <-newdataf_sub[newdataf_sub$season== "Early" & newdataf_sub$PlotType== "Canopy" &
                                  newdataf_sub$s.PC1 >= can_early_min & newdataf_sub$s.PC1 <= can_early_max ,  ]

newdataf_can_late <-newdataf_sub[newdataf_sub$season== "Late" & newdataf_sub$PlotType== "Canopy" &
                                    newdataf_sub$s.PC1 >= can_late_min & newdataf_sub$s.PC1 <= can_late_max ,  ]

newdataf_can_mid <-newdataf_sub[newdataf_sub$season== "Medium" & newdataf_sub$PlotType== "Canopy" &
                                   newdataf_sub$s.PC1 >= can_mid_min & newdataf_sub$s.PC1 <= can_mid_max ,  ]

# interior
newdataf_int_early <-newdataf_sub[newdataf_sub$season== "Early" & newdataf_sub$PlotType== "Interior" &
                                    newdataf_sub$s.PC1 >= int_early_min & newdataf_sub$s.PC1 <= int_early_max ,  ]

newdataf_int_late <-newdataf_sub[newdataf_sub$season== "Late" & newdataf_sub$PlotType== "Interior" &
                                   newdataf_sub$s.PC1 >= int_late_min & newdataf_sub$s.PC1 <= int_late_max ,  ]

newdataf_int_mid <-newdataf_sub[newdataf_sub$season== "Medium" & newdataf_sub$PlotType== "Interior" &
                                  newdataf_sub$s.PC1 >= int_mid_min & newdataf_sub$s.PC1 <= int_mid_max ,  ]

# open
newdataf_open_early <-newdataf_sub[newdataf_sub$season== "Early" & newdataf_sub$PlotType== "Open" &
                                    newdataf_sub$s.PC1 >= open_early_min & newdataf_sub$s.PC1 <= open_early_max ,  ]

newdataf_open_late <-newdataf_sub[newdataf_sub$season== "Late" & newdataf_sub$PlotType== "Open" &
                                   newdataf_sub$s.PC1 >= open_late_min & newdataf_sub$s.PC1 <= open_late_max ,  ]

newdataf_open_mid <-newdataf_sub[newdataf_sub$season== "Medium" & newdataf_sub$PlotType== "Open" &
                                  newdataf_sub$s.PC1 >= open_mid_min & newdataf_sub$s.PC1 <= open_mid_max ,  ]

#### recombine prediction dataframes ####
test <-rbind(newdataf_can_early, newdataf_can_late, newdataf_can_mid,
             newdataf_int_early, newdataf_int_late, newdataf_int_mid,
             newdataf_open_early,newdataf_open_late, newdataf_open_mid )

# Reorder factor levels for plotting
test$season   <- factor(test$season, levels = c("Early", "Medium", "Late"))
test$PlotType <- factor(test$PlotType, levels = c("Open", "Interior", "Canopy"))

newdataf_sub$season   <- factor(newdataf_sub$season, levels = c("Early", "Medium", "Late"))
newdataf_sub$PlotType <- factor(newdataf_sub$PlotType, levels = c("Open", "Interior", "Canopy"))


#### plot ####
# initial plot is for the original predictions
(p<-ggplot(newdataf_sub, aes(x = s.PC1, y = predicted,
                             group = PlotType, color = PlotType, fill = PlotType)) +
   
   # Add average line for each combination of PlotType and Season
   stat_summary(fun = "mean",  
                geom = "line", linewidth = 1, linetype =2) + 
   stat_summary(fun.data = "mean_cl_normal", 
                geom = "ribbon", alpha = 0.1) + 
   # Set the color and fill scale based on PlotType
   scale_color_manual(values = plot.cols) +
   scale_fill_manual(values = plot.cols) +
   
   # Facet the plot by Season
   facet_wrap(~season, scales = "fixed", ncol = 3, 
              labeller = labeller(season = seas.labs))  +
   
   # Customize the theme for a cleaner look
   theme_minimal() +
   theme(legend.position = "none",
         text = element_text(size = 15),
         plot.title = element_text(face = "bold")) +
   
   # Change legend title
   labs(x = "Openness", y = "", 
        title =  expression(paste(italic("Myotis "), "feeding activity"))) +
   scale_color_manual(name = "Habitat", values = plot.cols) +
   scale_fill_manual(name = "Habitat", values = plot.cols) +
   xlim(-3, 2)
)

# Now readd the predictions within range as an overlay
(predf<-p + 
    stat_summary(data = test, fun = "mean",  
                 geom = "line", linewidth = 1, linetype = 1, alpha=0.9) + 
    stat_summary(data = test, fun.data = "mean_cl_normal", 
                 geom = "ribbon", alpha = 0.75) )

################################################################################
################################################################################
################################################################################
################################################################################


### Myotis feeding activity predictions
# Subset to columns we are actually interested in for ease
newdatac_sub <-subset(newdatac, select = c("s.PC1", "season", "PlotType","predicted"))
myot.c_sub   <-subset(myot.c, select = c("s.PC1", "season", "PlotType"))

#### Find the ranges we want to predict within for each grouping ####
# Canopy
myot.c_sub_can_early <-myot.c_sub[myot.c_sub$season== "Early" & myot.c_sub$PlotType== "Canopy",  ]
can_early_max <-max(myot.c_sub_can_early$s.PC1)
can_early_min <-min(myot.c_sub_can_early$s.PC1)

myot.c_sub_can_late <-myot.c_sub[myot.c_sub$season== "Late" & myot.c_sub$PlotType== "Canopy",  ]
can_late_max <-max(myot.c_sub_can_late$s.PC1)
can_late_min <-min(myot.c_sub_can_late$s.PC1)

myot.c_sub_can_mid <-myot.c_sub[myot.c_sub$season== "Medium" & myot.c_sub$PlotType== "Canopy",  ]
can_mid_max <-max(myot.c_sub_can_mid$s.PC1)
can_mid_min <-min(myot.c_sub_can_mid$s.PC1)

# Interior
myot.c_sub_int_early <-myot.c_sub[myot.c_sub$season== "Early" & myot.c_sub$PlotType== "Interior",  ]
int_early_max <-max(myot.c_sub_int_early$s.PC1)
int_early_min <-min(myot.c_sub_int_early$s.PC1)

myot.c_sub_int_late <-myot.c_sub[myot.c_sub$season== "Late" & myot.c_sub$PlotType== "Interior",  ]
int_late_max <-max(myot.c_sub_int_late$s.PC1)
int_late_min <-min(myot.c_sub_int_late$s.PC1)

myot.c_sub_int_mid <-myot.c_sub[myot.c_sub$season== "Medium" & myot.c_sub$PlotType== "Interior",  ]
int_mid_max <-max(myot.c_sub_int_mid$s.PC1)
int_mid_min <-min(myot.c_sub_int_mid$s.PC1)

# Open
myot.c_sub_open_early <-myot.c_sub[myot.c_sub$season== "Early" & myot.c_sub$PlotType== "Open",  ]
open_early_max <-max(myot.c_sub_open_early$s.PC1)
open_early_min <-min(myot.c_sub_open_early$s.PC1)

myot.c_sub_open_late <-myot.c_sub[myot.c_sub$season== "Late" & myot.c_sub$PlotType== "Open",  ]
open_late_max <-max(myot.c_sub_open_late$s.PC1)
open_late_min <-min(myot.c_sub_open_late$s.PC1)

myot.c_sub_open_mid <-myot.c_sub[myot.c_sub$season== "Medium" & myot.c_sub$PlotType== "Open",  ]
open_mid_max <-max(myot.c_sub_open_mid$s.PC1)
open_mid_min <-min(myot.c_sub_open_mid$s.PC1)


#### Crop the predictions to these ranges ####
# canopy
newdatac_can_early <-newdatac_sub[newdatac_sub$season== "Early" & newdatac_sub$PlotType== "Canopy" &
                                  newdatac_sub$s.PC1 >= can_early_min & newdatac_sub$s.PC1 <= can_early_max ,  ]

newdatac_can_late <-newdatac_sub[newdatac_sub$season== "Late" & newdatac_sub$PlotType== "Canopy" &
                                    newdatac_sub$s.PC1 >= can_late_min & newdatac_sub$s.PC1 <= can_late_max ,  ]

newdatac_can_mid <-newdatac_sub[newdatac_sub$season== "Medium" & newdatac_sub$PlotType== "Canopy" &
                                   newdatac_sub$s.PC1 >= can_mid_min & newdatac_sub$s.PC1 <= can_mid_max ,  ]

# interior
newdatac_int_early <-newdatac_sub[newdatac_sub$season== "Early" & newdatac_sub$PlotType== "Interior" &
                                    newdatac_sub$s.PC1 >= int_early_min & newdatac_sub$s.PC1 <= int_early_max ,  ]

newdatac_int_late <-newdatac_sub[newdatac_sub$season== "Late" & newdatac_sub$PlotType== "Interior" &
                                   newdatac_sub$s.PC1 >= int_late_min & newdatac_sub$s.PC1 <= int_late_max ,  ]

newdatac_int_mid <-newdatac_sub[newdatac_sub$season== "Medium" & newdatac_sub$PlotType== "Interior" &
                                  newdatac_sub$s.PC1 >= int_mid_min & newdatac_sub$s.PC1 <= int_mid_max ,  ]

# open
newdatac_open_early <-newdatac_sub[newdatac_sub$season== "Early" & newdatac_sub$PlotType== "Open" &
                                    newdatac_sub$s.PC1 >= open_early_min & newdatac_sub$s.PC1 <= open_early_max ,  ]

newdatac_open_late <-newdatac_sub[newdatac_sub$season== "Late" & newdatac_sub$PlotType== "Open" &
                                   newdatac_sub$s.PC1 >= open_late_min & newdatac_sub$s.PC1 <= open_late_max ,  ]

newdatac_open_mid <-newdatac_sub[newdatac_sub$season== "Medium" & newdatac_sub$PlotType== "Open" &
                                  newdatac_sub$s.PC1 >= open_mid_min & newdatac_sub$s.PC1 <= open_mid_max ,  ]

#### recombine prediction dataframes ####
test <-rbind(newdatac_can_early, newdatac_can_late, newdatac_can_mid,
             newdatac_int_early, newdatac_int_late, newdatac_int_mid,
             newdatac_open_early,newdatac_open_late, newdatac_open_mid )

# Reorder factor levels for plotting
test$season   <- factor(test$season, levels = c("Early", "Medium", "Late"))
test$PlotType <- factor(test$PlotType, levels = c("Open", "Interior", "Canopy"))

newdatac_sub$season   <- factor(newdatac_sub$season, levels = c("Early", "Medium", "Late"))
newdatac_sub$PlotType <- factor(newdatac_sub$PlotType, levels = c("Open", "Interior", "Canopy"))


#### plot ####
# initial plot is for the original predictions
(p<-ggplot(newdatac_sub, aes(x = s.PC1, y = predicted,
                             group = PlotType, color = PlotType, fill = PlotType)) +
   
   # Add average line for each combination of PlotType and Season
   stat_summary(fun = "mean",  
                geom = "line", linewidth = 1, linetype =2) + 
   stat_summary(fun.data = "mean_cl_normal", 
                geom = "ribbon", alpha = 0.1) + 
   # Set the color and fill scale based on PlotType
   scale_color_manual(values = plot.cols) +
   scale_fill_manual(values = plot.cols) +
   
   # Facet the plot by Season
   facet_wrap(~season, scales = "fixed", ncol = 3, 
              labeller = labeller(season = seas.labs))  +
   
   # Customize the theme for a cleaner look
   theme_minimal() +
   theme(legend.position = "none",
         text = element_text(size = 15),
         plot.title = element_text(face = "bold")) +
   
   # Change legend title
   labs(x = "Openness", y = "Bat passes per night", 
        title =  expression(paste(italic("Myotis "), "commuting activity"))) +
   scale_color_manual(name = "Habitat", values = plot.cols) +
   scale_fill_manual(name = "Habitat", values = plot.cols) +
   xlim(-3, 2)
)

# Now readd the predictions within range as an overlay
(predc<-p + 
    stat_summary(data = test, fun = "mean",  
                 geom = "line", linewidth = 1, linetype = 1, alpha=0.9) + 
    stat_summary(data = test, fun.data = "mean_cl_normal", 
                 geom = "ribbon", alpha = 0.75) )


cowplot::plot_grid(predm, predp, predc, predf, nrow = 2, labels = c("a.", "b.", "c.", "d."))
ggsave(path = output_today, filename = "SREmodelPreds.tiff", width = 12, height = 8, device='tiff', dpi=600) 

```





## More general seasonal plot 
## Photoperiod plot - raw data 
Fig 6. Scatterplot of raw data (maybe not) model predictions smoother overlayed. Y = SRE bat activity (separate for each behavior) per site. Subset by PCA density (Split into 3 categories of high, medium, low, and faceted). X = daylength. H3, H5. 
Would be cool to have a figure with date along the x-axis and a double y-axis showing bat activity (points; maybe colored by plot type) and length of photoperiod (bars)
```{r}
coeff <- 1.2
# general<- ggplot(bats1 %>% 
#                   filter(manual.id == "MYOT") %>% 
#                   filter (behavior != "Social") %>% droplevels()) + 
#   geom_area(aes(x=jnight, y = day_length), fill = "#f0e2a8") +
#   geom_smooth(aes(x  = jnight, y = batpass, fill = PlotType), 
#               alpha = 0.8, color = "#3E4F73") + 
#   theme_minimal() + 
#   scale_fill_manual(values = plot.cols) +
#   facet_wrap(~behavior, nrow = 2) +
#   theme(text=element_text(size=20)) + 
#   xlab("Julian night") + 
#   ggtitle("Myotis") +
#   theme(legend.position = "none") +
#   scale_y_continuous(name = "Day length (hours)",
#                      sec.axis = 
#                        sec_axis(~.*coeff, 
#                             name ="Bat passes per night")) 
# general

mydf1 <- bats1 %>%filter(batpass>0) %>% 
                  filter(manual.id == "MYOT") %>% droplevels()
pldf1 <- bats1 %>%filter(batpass>0) %>% 
                  filter(manual.id == "PAUR") %>% droplevels()

coeff <- 0.25
general<- ggplot () + 
    geom_area(data = bats1, aes(x=jnight, y = day_length), fill = "#f0e2a8") +
    geom_vline(xintercept = 172, linetype="longdash", 
                color = "#cc8400", linewidth=1.5) +
  geom_vline(xintercept = 124, linetype="dotted", 
                color = "#ffb732", linewidth=1.5) +
  geom_vline(xintercept = 171, linetype="dotted", 
                color = "#ffb732", linewidth=1.5) +
  geom_vline(xintercept = 217, linetype="dotted", 
                color = "#ffb732", linewidth=1.5) +
  geom_vline(xintercept = 263, linetype="dotted", 
                color = "#ffb732", linewidth=1.5) +
  geom_smooth(data = mydf1, aes(x  = jnight, y = batpass), 
              alpha = 0.5, color = "#3E4F73", fill = "#C5DCF1") + 
  geom_smooth(data = pldf1, aes(x  = jnight, y = batpass), 
              alpha = 0.5, color = "#C5DCF1", fill = "#3E4F73") + 
  theme_minimal() + 
  theme(text=element_text(size=15)) + 
  xlab("Julian night") + 
    scale_y_continuous(name = "Bat passes per night",
                     sec.axis = 
                       sec_axis(~.*1, 
                            name ="Day length (hours)")) +
  ggtitle("") +
  theme(legend.position = "bottom") 

general

summary(bats1$day_length)

ggsave(path = output_today, filename = "DaylengthSREbats.tiff", width = 10, height = 8, device='tiff', dpi=300) 

```

windows()
library(cowplot)
behavpred <- cowplot::plot_grid(pred.f, pred.c, labels = c("a.", "b."), nrow = 2)
behavpred
## Checking color blindness 
cvdPlot(behavpred, layout = "deuteranope")

library(dichromat)
library(recolorize)

protan <- dichromat(plot.cols, type = "protan")
deutan <- dichromat(plot.cols, type = "deutan")
tritan <- dichromat(plot.cols, type = "tritan")

# plot for comparison
layout(matrix(1:4, nrow = 4)); par(mar = rep(1, 4))
recolorize::plotColorPalette(plot.cols, main = "Trichromacy")
recolorize::plotColorPalette(protan, main = "Protanopia")
recolorize::plotColorPalette(deutan, main = "Deutanopia")
recolorize::plotColorPalette(tritan, main = "Tritanopia")
